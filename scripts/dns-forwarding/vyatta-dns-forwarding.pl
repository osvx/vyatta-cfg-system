#!/usr/bin/perl
#
# Module: vyatta-dns-forwarding.pl
#
# **** License ****
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# This code was originally developed by Vyatta, Inc.
# Portions created by Vyatta are Copyright (C) 2008 Vyatta, Inc.
# All Rights Reserved.
#
# Author: Mohit Mehta
# Date: August 2008
# Description: Script to glue Vyatta CLI to dnsmasq daemon
#
# **** End License ****
#

use lib "/opt/vyatta/share/perl5/";
use Vyatta::Config;
use Vyatta::Misc;
use Getopt::Long;

use strict;
use warnings;

my $dnsforwarding_init = '/etc/init.d/dnsmasq';
my $dnsforwarding_conf = '/etc/dnsmasq.conf';


sub dnsforwarding_restart {
    system("$dnsforwarding_init restart >&/dev/null");
}

sub dnsforwarding_stop {
    system("$dnsforwarding_init stop >&/dev/null");
}

sub dnsforwarding_get_constants {
    my $output;

    my $date = `date`;
    chomp $date;
    $output  = "#\n# autogenerated by vyatta-dns-forwarding.pl on $date\n#\n";
    $output .= "log-facility=/var/log/dnsmasq.log\n";
    $output .= "no-poll\n";
    system("rm -f /var/log/dnsmasq.log; touch /var/log/dnsmasq.log");
    return $output;
}

sub dnsforwarding_get_values {

    my $outside_cli = shift;

    my $output = '';
    my $config = new Vyatta::Config;
    my $use_dnsmasq_conf = 0;
    my (@listen_interfaces, $cache_size, @use_nameservers, $use_system_nameservers, @use_dhcp_nameservers, @domain, $server);

    # advanced variables
    my (   @addn_hosts,
           $all_servers,
           @bogus_nxdomain,
           $bogus_priv,
           $dns_forward_max,
           @dnsmasq_option,
           $domain_needed,
           $edns_packet_max,
           $filterwin2k,
           @include_conf_dir,
           @include_conf_file,
           $local_ttl,
           $localise_queries,
           $max_ttl,
           $min_port,
           $neg_ttl,
           $no_hosts,
           $no_negcache,
           $port,
           $query_port,
           @rebind_domain_ok,
           $rebind_localhost_ok,
           @rewrite,
           @rewrite_wildcard,
           $stop_dns_rebind,
           $strict_order);

    # Handling variables
    my (   @zone,
           @interface,
           @redirect);

    my $dnsmasqversion = `dnsmasq -v | grep "Dnsmasq version" | cut -d " " -f3`;

    $config->setLevel("service dns forwarding");

    if ($outside_cli == 1){
           @listen_interfaces = $config->returnOrigValues("listen-on");
           $cache_size = $config->returnOrigValue("cache-size");
           @use_nameservers = $config->returnOrigValues("name-server");
           $use_system_nameservers = $config->existsOrig("system");
           @use_dhcp_nameservers = $config->returnOrigValues("dhcp");
           @domain = $config->listOrigNodes("domain");

    } else {
           @listen_interfaces = $config->returnValues("listen-on");
           $cache_size = $config->returnValue("cache-size");
           @use_nameservers = $config->returnValues("name-server");
           $use_system_nameservers = $config->exists("system");
	   @use_dhcp_nameservers = $config->returnValues("dhcp");
           @domain = $config->listNodes("domain");
    }

    $config->setLevel("service dns forwarding advanced");

    if ($outside_cli == 1){
           @addn_hosts = $config->returnOrigValues("addn-hosts");
           $all_servers = $config->existsOrig("all-servers");
           @bogus_nxdomain = $config->returnOrigValues("bogus-nxdomain");
           $bogus_priv = $config->existsOrig("bogus-priv");
           $dns_forward_max = $config->returnOrigValue("dns-forward-max");
           @dnsmasq_option = $config->returnOrigValues("dnsmasq-option");
           $domain_needed = $config->existsOrig("domain-needed");
           $edns_packet_max = $config->returnOrigValue("edns-packet-max");
           $filterwin2k = $config->existsOrig("filterwin2k");
           @include_conf_dir = $config->returnOrigValues("include-conf-dir");
           @include_conf_file = $config->returnOrigValues("include-conf-file");
           $local_ttl = $config->returnOrigValue("local-ttl");
           $localise_queries = $config->existsOrig("localise-queries");
           $max_ttl = $config->returnOrigValue("max-ttl");
           $min_port = $config->returnOrigValue("min-port");
           $neg_ttl = $config->returnOrigValue("neg-ttl");
           $no_hosts = $config->existsOrig("no-hosts");
           $no_negcache = $config->existsOrig("no-negcache");
           $port = $config->returnOrigValue("port");
           $query_port = $config->returnOrigValue("query-port");
           @rebind_domain_ok = $config->returnOrigValues("rebind-domain-ok");
           $rebind_localhost_ok = $config->existsOrig("rebind-localhost-ok");
           @rewrite = $config->listOrigNodes("rewrite");
           @rewrite_wildcard = $config->listOrigNodes("rewrite-wildcard");
           $stop_dns_rebind = $config->existsOrig("stop-dns-rebind");
           $strict_order = $config->existsOrig("strict-order");
    } else {
           @addn_hosts = $config->returnValues("addn-hosts");
           $all_servers = $config->exists("all-servers");
           @bogus_nxdomain = $config->returnValues("bogus-nxdomain");
           $bogus_priv = $config->exists("bogus-priv");
           $dns_forward_max = $config->returnValue("dns-forward-max");
           @dnsmasq_option = $config->returnValues("dnsmasq-option");
           $domain_needed = $config->exists("domain-needed");
           $edns_packet_max = $config->returnValue("edns-packet-max");
           $filterwin2k = $config->exists("filterwin2k");
           @include_conf_dir = $config->returnValues("include-conf-dir");
           @include_conf_file = $config->returnValues("include-conf-file");
           $local_ttl = $config->returnValue("local-ttl");
           $localise_queries = $config->exists("localise-queries");
           $max_ttl = $config->returnValue("max-ttl");
           $min_port = $config->returnValue("min-port");
           $neg_ttl = $config->returnValue("neg-ttl");
           $no_hosts = $config->exists("no-hosts");
           $no_negcache = $config->exists("no-negcache");
           $port = $config->returnValue("port");
           $query_port = $config->returnValue("query-port");
           @rebind_domain_ok = $config->returnValues("rebind-domain-ok");
           $rebind_localhost_ok = $config->exists("rebind-localhost-ok");
           @rewrite = $config->listNodes("rewrite");
           @rewrite_wildcard = $config->listNodes("rewrite-wildcard");
           $stop_dns_rebind = $config->exists("stop-dns-rebind");
           $strict_order = $config->exists("strict-order");
    }


    $config->setLevel("service dns forwarding handling");

    if ($outside_cli == 1){
          @zone = $config->listOrigNodes("zone");
          @interface = $config->listOrigNodes("interface");
          @redirect = $config->listOrigNodes("redirect");
    } else {
          @zone = $config->listNodes("zone");
          @interface = $config->listNodes("interface");
          @redirect = $config->listNodes("redirect");
    }


    ### Basic options

    if (@listen_interfaces != 0) {
       foreach my $interface (@listen_interfaces) {
          $output .= "interface=$interface\n";
       }
    }

    if (defined $cache_size) {
        $output .= "cache-size=$cache_size\n";
    }

    if (@use_nameservers != 0){
        $use_dnsmasq_conf = 1;
        foreach my $cli_nameserver (@use_nameservers) {
                   $output .= "server=$cli_nameserver\t# statically configured\n";
           }
    }

    if (defined($use_system_nameservers)) {
	$use_dnsmasq_conf = 1;
        my $sys_config = new Vyatta::Config;
        $sys_config->setLevel("system");
        my @system_nameservers;
        if ($outside_cli == 1){
            @system_nameservers = $sys_config->returnOrigValues("name-server");
        } else {
            @system_nameservers = $sys_config->returnValues("name-server");
        }
        if (@system_nameservers > 0) {
           foreach my $system_nameserver (@system_nameservers) {
                   $output .= "server=$system_nameserver\t# system\n";
           }     
        }
    }
    if (@domain != 0) {
        foreach my $dom (@domain) {
            my $ser = $config->returnValue("domain $dom server");
            if (defined ($ser)) {
                $output .="server=/$dom/$ser\t# domain-override\n";
            }
        } 
    }

    if (@use_dhcp_nameservers != 0) {
	$use_dnsmasq_conf = 1;
        foreach my $interface (@use_dhcp_nameservers) {
           my $dhcp_nameserver_count=`grep nameserver /etc/resolv.conf.dhclient-new-$interface 2>/dev/null | wc -l`;
           if ($dhcp_nameserver_count > 0) {
	       my @dhcp_nameservers = `grep nameserver /etc/resolv.conf.dhclient-new-$interface`;
	       for my $each_nameserver (@dhcp_nameservers) {
	          my @nameserver = split(/ /, $each_nameserver, 2);
                  my $ns = $nameserver[1];
                  chomp $ns;
                  $output .= "server=$ns\t# dhcp $interface\n";
               }
           } 
        }
    }

    if ($use_dnsmasq_conf == 1) {
        $output .= "resolv-file=/etc/dnsmasq.conf\n";
    }

    ### Advanced options

    if (@addn_hosts != 0) {
      foreach my $hostfile (@addn_hosts) {
        if (-d $hostfile && $dnsmasqversion < 2.48) {
          print "DNS forwarding warning: Dnsmasq version needs to be at least 2.48 to use addn-hosts with directories.\n\t\t-> $hostfile ignored.\n";
        } elsif (-f $hostfile || -d $hostfile) {
          $output .= "addn-hosts=$hostfile\n";
        } else {
          die "DNS forwarding error: add-hosts source '$hostfile' does not exist.\n";
        }
      }
    }

    if (defined($all_servers)) {
	$output .= "all-servers\n";
    }

    if (@bogus_nxdomain != 0) {
       foreach my $ipaddress (@bogus_nxdomain) {
          $output .= "bogus-nxdomain=$ipaddress\n";
       }
    }

    if (@dnsmasq_option != 0) {
       foreach my $option (@dnsmasq_option) {
          $output .= "$option\n";
       }
    }

    if (defined($bogus_priv)) {
        $output .= "bogus-priv\n";
    }

    if (defined($dns_forward_max)) {
        $output .= "dns-forward-max=$dns_forward_max\n";
    }

    if (defined($domain_needed)) {
        $output .= "domain-needed\n";
    }

    if (defined($edns_packet_max)) {
        $output .= "edns-packet-max=$edns_packet_max\n";
    }

    if (defined($filterwin2k)) {
        $output .= "filterwin2k\n";
    }

    if (@include_conf_dir != 0) {
       foreach my $directory (@include_conf_dir) {
          $output .= "include-conf-dir=$directory\n";
       }
    }

    if (@include_conf_file != 0) {
       foreach my $filepath (@include_conf_file) {
          $output .= "include-conf-file=$filepath\n";
       }
    }

    if (defined($local_ttl)) {
        $output .= "local-ttl=$local_ttl\n";
    }

    if (defined($localise_queries)) {
        $output .= "localise-queries\n";
    }

    if (defined($max_ttl)) {
        if ($dnsmasqversion < 2.53) {
          die "DNS forwarding error: Dnsmasq version needs to be at least 2.53 to use max-ttl.\n";
        } else {
          $output .= "max-ttl=$max_ttl\n";
        }
    }

    if (defined($min_port)) {
        $output .= "min-port=$min_port\n";
    }

    if (defined($neg_ttl)) {
        $output .= "neg-ttl=$neg_ttl\n";
    }

    if (defined($no_hosts)) {
        $output .= "no-hosts\n";
    }

    if (defined($no_negcache)) {
        $output .= "no-negcache\n";
    }

    if (defined($port)) {
        $output .= "port=$port\n";
    }

    if (defined($query_port)) {
        $output .= "query-port=$query_port\n";
    }

    if (@rebind_domain_ok != 0) {
       if ($dnsmasqversion < 2.53) {
         die "DNS forwarding error: Dnsmasq version needs to be at least 2.53 to use rebind-domain-ok.\n";
       } else {
         $output .= "rebind-domain-ok=/";
         foreach my $domain (@rebind_domain_ok) {
            $output .= "$domain/";
         }
         $output .= "\n";
       }
    }

    if (defined($rebind_localhost_ok)) {
       if ($dnsmasqversion < 2.53) {
         die "DNS forwarding error: Dnsmasq version needs to be at least 2.53 to use rebind-localhost-ok.\n";
       } else {
         $output .= "rebind-localhost-ok\n";
       }
    }

    if (@rewrite != 0) {
      foreach my $node (@rewrite) {
        $config->setLevel("service dns forwarding advanced rewrite $node");
        my $newip = $config->returnValue("new-ip");
        my $mask = $config->returnValue("mask");
        my $isdisabled = $config->exists("disable");
        my @aliases = $config->returnValues("alias");
      
        if (defined($isdisabled)) { next; }
        if (!defined($newip)) { die "DNS forwarding error: Definition of new-ip is mandatory for rewrite of IP $node.\n"; }
 
        if ($node =~ /-/ && $dnsmasqversion < 2.47) {
          die "DNS forwarding error: Dnsmasq version needs to be at least 2.47 to use rewrite with IP ranges.\n";
        } elsif ($node =~ /-/ && !defined($mask)) {
          die "DNS forwarding error: No mask specified for IP range rewrite $node.\n";
        } 

        $output .= "alias=$node,$newip";

        if (defined($mask) && $dnsmasqversion < 2.47) {
          die "DNS forwarding error: Dnsmasq version needs to be at least 2.47 to use rewrite with masks.\n";
        } elsif (defined($mask)) {
          $output .= ",$mask";
        }

        $output .= "\n";

        if (@aliases != 0) {
          foreach my $nodealias (@aliases) {
            if ($nodealias =~ /-/ && $dnsmasqversion < 2.47) {
              die "DNS forwarding error: Dnsmasq version needs to be at least 2.47 to use rewrite with IP ranges (alias error).\n";
            } elsif ($nodealias =~ /-/ && !defined($mask)) {
              die "DNS forwarding error: IP range rewrite $nodealias is an alias for $node but no mask was specified for this node.\n";
            }

            $output .= "alias=$nodealias,$newip";

            if (defined($mask)) {
              $output .= ",$mask";
            }

            $output .= "\n";
          }
        }
      }
    }


    if (defined($stop_dns_rebind)) {
        $output .= "stop-dns-rebind\n";
    }

    if (defined($strict_order)) {
        $output .= "strict-order\n";
    }


    ### Handling options

    if (@zone != 0) {
      foreach my $node (@zone) {
        $config->setLevel("service dns forwarding handling zone $node");
        my @recordsA = $config->listNodes("A");
        my @recordsAAAA = $config->listNodes("AAAA");
        my @recordsCNAME = $config->listNodes("CNAME");
        my @recordsMX = $config->listNodes("MX");
        my @recordsPTR = $config->listNodes("PTR");
        my @recordsSRV = $config->listNodes("SRV");
        my @recordsTXT = $config->listNodes("TXT");
        my $authorative = $config->exists("local-only");
        my $isdisabled = $config->exists("disable");
        my @aliases = $config->returnValues("alias");

        if (defined($isdisabled)) { next; }
        if (!defined($authorative) && @recordsA == 0 && @recordsAAAA == 0 && @recordsCNAME == 0 && @recordsMX == 0 && @recordsPTR == 0 && @recordsSRV == 0 && @recordsTXT == 0) {
          die "DNS forwarding error: Definition of at least one record or local-only option is mandatory for forward DNS zone $node.\n"; }

        # Create A records
        foreach my $recordA (@recordsA) {
          $config->setLevel("service dns forwarding handling zone $node A $recordA");
          my @recordAaddrs = $config->returnValues("address");
          my @recordAaliases = $config->returnValues("alias");
          my @recordAexcepts = $config->returnValues("except-subdomain");
          my $recordAisdisabled = $config->exists("disable");
          my $recordAautorev = $config->exists("auto-reverse");

          if (defined($recordAisdisabled)) { next; }
          if (@recordAaddrs == 0) { die "DNS forwarding error: IPv4 pointer address for A record $recordA in DNS forward zone $node is missing.\n"; }

          if ($recordA eq "\@") { $recordA = ""; } else { $recordA .= "." }

          # Handle each defined destination IP address
          foreach my $recordAaddr (@recordAaddrs) {
            $output .= "address=/$recordA$node";
            if (@recordAaliases != 0) {
              foreach my $recordAalias (@recordAaliases) {
                $output .= "/$recordAalias.$node";
              }
            }
            $output .= "/$recordAaddr\n";

            # Handle node aliases
            if (@aliases != 0) {
              $output .= "address=";
              foreach my $nodealias (@aliases) {
                $output .= "/$recordA$nodealias";
                if (@recordAaliases != 0) {
                  foreach my $recordAalias (@recordAaliases) {
                    $output .= "/$recordAalias.$nodealias";
                  }
                } 
              }
              $output .= "/$recordAaddr\n";
            }

            # Handle subdomain exceptions
            if (@recordAexcepts != 0 && $dnsmasqversion < 2.53) {
              print "DNS forwarding warning: Dnsmasq version needs to be at least 2.53 to define exceptions for A record $recordA$node. Exceptions ignored.\n";
            } elsif (@recordAexcepts != 0) {
              foreach my $recordAexcept (@recordAexcepts) {
                $output .= "address=/$recordAexcept.$recordA$node";
                if (@recordAaliases != 0) {
                  foreach my $recordAalias (@recordAaliases) {
                    $output .= "/$recordAexcept.$recordAalias.$node";
                  }
                }
                $output .= "/#\n";
                if (@aliases != 0) {
                  $output .= "address=";
                  foreach my $nodealias (@aliases) {
                    $output .= "/$recordAexcept.$recordA$nodealias";
                    if (@recordAaliases != 0) {
                      foreach my $recordAalias (@recordAaliases) {
                        $output .= "/$recordAexcept.$recordAalias.$nodealias";
                      }
                    }
                  }
                  $output .= "/#\n";
                }
              }
            }

            # Create PTR reverse records if requested
            if (defined($recordAautorev)) {
              $output .= "ptr-record=".join('.', reverse split(/\./, $recordAaddr)).".in-addr.arpa,$recordA$node\n";
            }

          } # end foreach addresses 
        } # end foreach recordA


        # Create AAAA records
        foreach my $recordAAAA (@recordsAAAA) {
          $config->setLevel("service dns forwarding handling zone $node AAAA $recordAAAA");
          my @recordAAAAaddrs = $config->returnValues("address6");
          my @recordAAAAaliases = $config->returnValues("alias");
          my @recordAAAAexcepts = $config->returnValues("except-subdomain");
          my $recordAAAAisdisabled = $config->exists("disable");
          my $recordAAAAautorev = $config->exists("auto-reverse");

          if (defined($recordAAAAisdisabled)) { next; }
          if (@recordAAAAaddrs == 0) { die "DNS forwarding error: IPv6 pointer address for AAAA record $recordAAAA in DNS forward zone $node is missing.\n"; }

          if ($recordAAAA eq "\@") { $recordAAAA = ""; } else { $recordAAAA .= "." }

          # Handle each defined destination IP address
          foreach my $recordAAAAaddr (@recordAAAAaddrs) {
            $output .= "address=/$recordAAAA$node";
            if (@recordAAAAaliases != 0) {
              foreach my $recordAAAAalias (@recordAAAAaliases) {
                $output .= "/$recordAAAAalias.$node";
              }
            }
            $output .= "/$recordAAAAaddr\n";

            # Handle node aliases
            if (@aliases != 0) {
              $output .= "address=";
              foreach my $nodealias (@aliases) {
                $output .= "/$recordAAAA$nodealias";
                if (@recordAAAAaliases != 0) {
                  foreach my $recordAAAAalias (@recordAAAAaliases) {
                    $output .= "/$recordAAAAalias.$nodealias";
                  }
                }
              }
              $output .= "/$recordAAAAaddr\n";
            }

            # Handle subdomain exceptions
            if (@recordAAAAexcepts != 0 && $dnsmasqversion < 2.53) {
              print "DNS forwarding warning: Dnsmasq version needs to be at least 2.53 to define exceptions for AAAA record $recordAAAA$node. Exceptions ignored.\n";
            } elsif (@recordAAAAexcepts != 0) {
              foreach my $recordAAAAexcept (@recordAAAAexcepts) {
                $output .= "address=/$recordAAAAexcept.$recordAAAA$node";
                if (@recordAAAAaliases != 0) {
                  foreach my $recordAAAAalias (@recordAAAAaliases) {
                    $output .= "/$recordAAAAexcept.$recordAAAAalias.$node";
                  }
                }
                $output .= "/#\n";
                if (@aliases != 0) {
                  $output .= "address=";
                  foreach my $nodealias (@aliases) {
                    $output .= "/$recordAAAAexcept.$recordAAAA$nodealias";
                    if (@recordAAAAaliases != 0) {
                      foreach my $recordAAAAalias (@recordAAAAaliases) {
                        $output .= "/$recordAAAAexcept.$recordAAAAalias.$nodealias";
                      }
                    }
                  }
                  $output .= "/#\n";
                }
              }
            }

            # Create PTR reverse records if requested
            if (defined($recordAAAAautorev)) {
              $output .= "ptr-record=".join('.', reverse split(/\./, $recordAAAAaddr)).".ip6.arpa,$recordAAAA$node\n";
            }

          } # end foreach addresses
        } # end foreach recordAAAA


        # Create CNAME records
        if (@recordsCNAME != 0 && $dnsmasqversion < 1.46) {
          die "DNS forwarding error: Dnsmasq version needs to be at least 2.43 to use CNAME records.\n";
        } elsif (@recordsCNAME != 0) {
          foreach my $recordCNAME (@recordsCNAME) {
            $config->setLevel("service dns forwarding handling zone $node CNAME $recordCNAME");
            my $recordCNAMEdest = $config->returnValue("hostname");
            my $recordCNAMEisdisabled = $config->exists("disable");

            if (defined($recordCNAMEisdisabled)) { next; }
            if (!defined($recordCNAMEdest)) { die "DNS forwarding error: CNAME $node does not have a destination pointer specified.\n"; }

            if ($recordCNAME eq "\@") { $recordCNAME = ""; } else { $recordCNAME .= "." }

            $output .= "cname=$recordCNAME$node,$recordCNAMEdest\n";

            if (@aliases != 0) {
              foreach my $nodealias (@aliases) {
                $output .= "cname=$recordCNAME$nodealias,$recordCNAMEdest\n";
              }
            }
          }
        }


        # Create MX records
        foreach my $recordMX (@recordsMX) {
          $config->setLevel("service dns forwarding handling zone $node MX $recordMX");
          my $recordMXhost = $config->returnValue("hostname");
          my $recordMXpref = $config->returnValue("preference");
          my $recordMXisdisabled = $config->exists("disable");

          if (defined($recordMXisdisabled)) { next; }
          if (!defined($recordMXhost)) { die "DNS forwarding error: MX record $node does not have a hostname specified.\n"; }

          if ($recordMX eq "\@") { $recordMX = ""; } else { $recordMX .= "." }

          $output .= "mx-host=$recordMX$node,$recordMXhost";
          if (defined($recordMXpref)) {
            $output .= ",$recordMXpref";
          }
          $output .= "\n";

          if (@aliases != 0) {
            foreach my $nodealias (@aliases) {
              $output .= "mx-host=$recordMX$nodealias,$recordMXhost";
              if (defined($recordMXpref)) {
                $output .= ",$recordMXpref";
              }
              $output .= "\n";
            }
          }
        }


        # Create PTR records
        foreach my $recordPTR (@recordsPTR) {
          $config->setLevel("service dns forwarding handling zone $node PTR $recordPTR");
          my $recordPTRhost = $config->returnValue("hostname");
          my $recordPTRisdisabled = $config->exists("disable");

          if (defined($recordPTRisdisabled)) { next; }
          if (!defined($recordPTRhost)) { die "DNS forwarding error: Canonical hostname for PTR reverse DNS record $recordPTR.$node is missing.\n"; }

          if ($recordPTR eq "\@") { $recordPTR = ""; } else { $recordPTR .= "." }

          $output .= "ptr-record=$recordPTR$node,$recordPTRhost\n";

          if (@aliases != 0) {
            foreach my $nodealias (@aliases) {
              $output .= "ptr-record=$recordPTR$nodealias,$recordPTRhost\n";
            }
          }
        }


        # Create SRV records
        foreach my $recordSRV (@recordsSRV) {
          $config->setLevel("service dns forwarding handling zone $node SRV $recordSRV");
          my $recordSRVhost = $config->returnValue("hostname");
          my $recordSRVport = $config->returnValue("port");
          my $recordSRVweight = $config->returnValue("weight");
          my $recordSRVprio = $config->returnValue("priority");
          my $recordSRVisdisabled = $config->exists("disable");

          if (defined($recordSRVisdisabled)) { next; }
          if (!defined($recordSRVhost) || !defined($recordSRVport)) { die "DNS forwarding error: SRV record $node needs to have hostname and port specified.\n"; }

          if ($recordSRV eq "\@") { $recordSRV = ""; } else { $recordSRV .= "." }

          $output .= "srv-host=$recordSRV$node,$recordSRVhost,$recordSRVport";

          if (defined($recordSRVprio)) {
            $output .= ",$recordSRVprio";
          } elsif (defined($recordSRVweight)) {
            $output .= ",0";
          }

          if (defined($recordSRVweight)) {
            $output .= ",$recordSRVweight";
          }

          $output .= "\n";
        }


        # Create TXT records
        foreach my $recordTXT (@recordsTXT) {
          $config->setLevel("service dns forwarding handling zone $node TXT $recordTXT");
          my $recordTXTtext = $config->returnValue("text");
          my $recordTXTisdisabled = $config->exists("disable");
        
          if (defined($recordTXTisdisabled)) { next; }
          if (!defined($recordTXTtext)) { die "DNS forwarding error: TXT record $node needs to have content text specified.\n"; }

          if ($recordTXT eq "\@") { $recordTXT = ""; } else { $recordTXT .= "." }
        
          $output .= "txt-record=$recordTXT$node,$recordTXTtext\n";
        } 


        # prevent to forward queries to upstream servers if requested
        if (defined($authorative)) {
          $output .= "local=/$node/\n";
        }

      } # end foreach zone node
    } # end foreach forward section


    # Create forward and reverse lookups for interface IPs (IPv4 only)
    if (@interface != 0) {
      foreach my $node (@interface) {
        $config->setLevel("service dns forwarding handling interface $node");
        my @ifnames = $config->returnValues("name");

        if (@ifnames == 0) { die "DNS forwarding error: Definition of name is mandatory for DNS naming of interface $node.\n"; }

        foreach my $ifname (@ifnames) {
          $output .= "interface-name=$ifname,$node\n";
        }
      }
    }


    # Create DNS redirections
    if (@redirect != 0) {
      foreach my $node (@redirect) {
        $config->setLevel("service dns forwarding handling redirect $node");
        my @nameservers = $config->returnValues("name-server");
        my $port = $config->returnValue("port");
        my $srcint = $config->returnValue("source-interface");
        my $srcaddr = $config->returnValue("source-address");
        my $srcport = $config->returnValue("source-port");
        my $isdisabled = $config->exists("disable");
        my @aliases = $config->returnValues("alias");
        my @excepts = $config->returnValues("except");

        if (defined($isdisabled)) { next; }
        if (@nameservers == 0) { die "DNS forwarding error: Definition of name-server is mandatory for DNS redirect of $node.\n"; }
        if (defined($srcint) && defined($srcaddr)) { die "DNS forwarding error: You may only declare source-address or source-interface at once in DNS redirect for $node.\n"; }
        if (defined($srcport) && (!defined($srcaddr) && !defined($srcint)) ) { die "DNS forwarding error: Definition of source-port needs at least source-address or source-interface to be declared in DNS redirect for $node.\n"; }

        foreach my $nameserver (@nameservers) {
          $output .= "server=/$node";

          foreach my $nodealias (@aliases) {
            $output .= "/$nodealias";
          }

          $output .= "/$nameserver";

          if (defined($port)) {
            $output .= "#$port";
          }

          if (defined($srcaddr)) {
            $output .= "\@$srcaddr";
          } elsif (defined($srcint)) {
            $output .= "\@$srcint";
          }

          if (defined($srcport)) {
            $output .= "#$srcport";
          }

          $output .= "\n";
        }

        if (@excepts != 0) {
          if ($dnsmasqversion < 2.53) {
            print "DNS forwarding warning: Dnsmasq version needs to be at least 2.53 to define exceptions for DNS redirect of $node. Exceptions ignored.\n";
          } else {
            foreach my $except (@excepts) {
              if ($except =~ /$node/) {
                $output .= "server=/$except/#\n";
              } else {
                $output .= "server=/$except.$node";
                if (@aliases != 0) {
                  foreach my $nodealias (@aliases) {
                    $output .= "/$except.$nodealias";
                  }
                }
                $output .= "/#\n";
              }
            }
          }
        }
      }
    }

    return $output;
}

sub dnsforwarding_write_file {
    my ($config) = @_;

    open(my $fh, '>', $dnsforwarding_conf) || die "Couldn't open $dnsforwarding_conf - $!";
    print $fh $config;
    close $fh;
}

sub check_nameserver {

    my $cmd = `cat /etc/resolv.conf 2>/dev/null | awk {'print \$1'} | grep \^nameserver\$ | wc -l`;
    return $cmd;
}

sub check_system_nameserver {

    my $config = new Vyatta::Config;
    $config->setLevel("system");
    my @system_nameservers = $config->returnValues("name-server");
    return(@system_nameservers);

}

sub check_dhcp_interface {

    my $interface = shift;

    die "DNS forwarding error: $interface is not using DHCP to get an IP address\n"
        unless Vyatta::Misc::is_dhcp_enabled($interface);

    if (-e "/var/run/vyatta/dhclient/dhclient_release_$interface") {
       # dhcp released for the interface
       print "DNS forwarding warning: DHCP lease for $interface has been released by user\n";
    }

    return 1;
}


#
# main
#

my ($update_dnsforwarding, $stop_dnsforwarding, $system_nameserver, $dhcp_interface, $outside_cli);

GetOptions("update-dnsforwarding!"         => \$update_dnsforwarding,
           "stop-dnsforwarding!"           => \$stop_dnsforwarding,
           "system-nameserver!"            => \$system_nameserver,
	   "outside-cli!"                  => \$outside_cli,
           "dhcp-interface=s"              => \$dhcp_interface);

if (defined $system_nameserver) {
    my $system_nameserver_exists = check_system_nameserver();
    if ($system_nameserver_exists < 1){
	print "DNS forwarding warning: No name-servers set under 'system name-server'\n";
    }
}

if (defined $dhcp_interface) {
    if (!check_dhcp_interface($dhcp_interface)){
        exit 1;
    }
}

if (defined $update_dnsforwarding) {
    my $config;
    my $vyatta_config = new Vyatta::Config;

    $vyatta_config->setLevel("service dns forwarding");
    my $use_system_nameservers = $vyatta_config->exists("system");
    my @use_dhcp_nameservers = $vyatta_config->returnValues("dhcp");
    my @use_nameservers = $vyatta_config->returnValues("name-server");

    if (!(defined $use_system_nameservers) && (@use_dhcp_nameservers == 0) && (@use_nameservers == 0)) {
       my $nameserver_exists = check_nameserver();
       if ($nameserver_exists < 1){
           print "DNS forwarding warning: Currently, no name-servers to forward DNS queries\n";
       }
    }

    my $called_from_outside_cli = 0;
    if (defined $outside_cli){
	$called_from_outside_cli = 1;
    }
    $config  = dnsforwarding_get_constants();
    $config .= dnsforwarding_get_values($called_from_outside_cli);
    dnsforwarding_write_file($config);
    dnsforwarding_restart();
}

if (defined $stop_dnsforwarding) {
    dnsforwarding_stop();
}

exit 0;

# end of file

